# -----------------------------------------------------------------------------
# Copyright (c) 2014--, The LabAdmin Development Team.
#
# Distributed under the terms of the BSD 3-clause License.
#
# The full license is in the file LICENSE, distributed with this software.
# -----------------------------------------------------------------------------

from StringIO import StringIO
import io

import pandas as pd
import numpy as np


def parse_plate_reader_output(contents):
    """Parses the output of a plate reader
    The format supported here is a tab delimited file in which the first line
    contains the fitting curve followed by (n) blank lines and then a tab
    delimited matrix with the values

    Parameters
    ----------
    contents : str
        The contents of the plate reader output

    Returns
    -------
    np.array of floats
        A 2D array of floats
    """
    data = []
    for line in contents.splitlines():
        line = line.strip()
        if not line or line.startswith('Curve'):
            continue
        data.append(line.split())

    return np.asarray(data, dtype=np.float)


def parse_qpcr_object(contents):
    """ Parses a QPCR machine string, returning the per well Cps

    Parameters
    ----------
    contents : str
        The string generated by the QPCR machine to parse.
        New lines \n, field ,

    Returns
    -------
    numpy.array 2D
        The per well concentrations

    Raises
    ------
        ValueError
            If Cp or Pos is not one of the headers
    """
    contents = pd.read_csv(
            StringIO(contents),
            sep=',',
            dtype=str,
            encoding='utf-8',
            infer_datetime_format=False,
            keep_default_na=False,
            index_col=False,
            comment='\t',
            skiprows=1)

    headers = contents.columns.values
    if 'Cp' not in headers or 'Pos' not in headers:
        raise ValueError("The 'Cp' and 'Pos' headers are "
                         "required. The ones present are: %s" % headers)

    # Pos format is A1 -> [0][0], B24 -> [1][23], etc so the max row will
    # be the first letter - 'A' + 1
    max_row = sorted(contents.Pos.values,
                     key=lambda item: item[0])[-1][0]
    max_row = ord(max_row) - ord('A') + 1
    # the max columns is the max number after the letter - 1
    max_col = sorted(contents.Pos.values,
                     key=lambda item: int(item[1:]))[-1][1:]
    max_col = int(max_col)

    result = np.empty((max_row, max_col))
    result[:] = np.nan

    for idx, row in contents.iterrows():
        # if Cp is empty default to nan
        value = float(row.Cp) if row.Cp != '' else np.nan
        r = ord(row.Pos[0]) - ord('A')
        c = int(row.Pos[1:]) - 1
        result[r, c] = value

    return result


def _find_section(lines, label):
    """Find a section, eg [EXCEPTIONS]

    Parameters
    ----------
    lines : list of str
        The data to search over
    label : str
        The section header to search for

    Returns
    -------
    int
        The index of the header
    int
        The index of the first empty line following the section, or the index
        position of the end of the file.

    Raises
    ------
    ValueError
        If the section is not found
    """
    start = -1
    end = len(lines)
    for idx, line in enumerate(lines):
        if line.startswith(label):
            start = idx
            break

    if start == -1:
        raise ValueError('%s section appears to be missing' % label)

    for idx, line in enumerate(lines[start:], start + 1):
        if not line or line == '':
            end = idx
            break

    return start, end


def parse_echo(data):
    """Parse the Echo output file

    Parameters
    ----------
    data : str
        A str representation of the file

    Returns
    -------
    pd.DataFrame
        A DataFrame composed of the [EXCEPTIONS] section
    pd.DataFrame
        A DataFrame composed of the [DETAILS] section

    Raises
    ------
    ValueError
        If the header is missing
        If the exceptions section is missing
        If the details section is missing
    """
    data = data.splitlines()
    if not data[0].startswith('Run ID'):
        raise ValueError('File header appears to be missing')

    exception_start, exception_end = _find_section(data, '[EXCEPTIONS]')
    details_start, details_end = _find_section(data, '[DETAILS]')

    exception_lines = data[exception_start+1:exception_end]
    exception_section = io.StringIO(u'\n'.join(exception_lines))
    exceptions = pd.read_csv(exception_section, dtype=str)

    details_lines = data[details_start+1:details_end]
    details_section = io.StringIO(u'\n'.join(details_lines))
    details = pd.read_csv(details_section, dtype=str)

    return exceptions, details


def parse_plate_reader_output_multiple(data):
    """Parse a qubit essay file

    Parameters
    ----------
    data : str
        A str representation of the file

    Returns
    -------
    pd.DataFrame
        A DataFrame composed of the [EXCEPTIONS] section
    pd.DataFrame
        A DataFrame composed of the [DETAILS] section

    Raises
    ------
    ValueError
        If one of the rows has less than 14 values
        If each value line doesn't start with the expected char
        If the details section is missing
    """
    data = data.splitlines()
    # check how many frames headers we have
    # i + 3 cause we want to start 3 lines below as 1 is the header line, 2 is
    # the blank line just after the header, and the 3 one is the row with
    # numbers
    frames = [i + 3 for i, d in enumerate(data) if d.startswith('Curve')]
    qubit = [np.zeros((8, 12)) for i in range(len(frames))]

    # start reading each frame
    for i, fidx in enumerate(frames):
        lines_read = 0
        # each frame should contain H rows
        while lines_read < 8:
            # [:-1] to ignore the last value which is "[Concentration]"
            line = data[fidx].split('\t')[:-1]

            if len(line) != 13:
                raise ValueError(
                    "We expect 14 columns in all lines but line %s of frame "
                    "%s only has %d: %s" % (lines_read + 1, i + 1, len(line),
                                            line))

            if line[0] != chr(ord('A') + lines_read):
                raise ValueError(
                    'Wrong row value: %c, it should be: %c, on line %d, of '
                    'frame %d' % (line[0], chr(ord('A') + lines_read),
                                  lines_read + 1, i + 1))

            for j, v in enumerate(line[1:]):
                qubit[i][lines_read, j] = float(v)

            fidx += 1
            lines_read += 1

    return qubit
